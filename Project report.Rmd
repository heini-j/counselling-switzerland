---
title: "Project report"
author: "Heini Järviö"
date: "2024-05-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Availability of appropriate healthcare is essential for healthy human life. Psychiatric illnesses are currently one of the leading causes for absence from work, health related suffering and blabla. Fast access to appropriate treatment can prevent cronic illness and further complications. Since 2020, Switzerland has eased access to psychological counselling by including psychologists' interventions in basic insurance. The largest association for psychologists (FSP) in Switzerland provides information to the habitants and lists available services around the country.

## Aim of the project:

In this project I utilise the information on counselling providers around Switzerland as provided by FSP's Psyfinder. The aim of the project is to map councelling providers in different area codes, while using several accessibility filters, such as inclusion in the basic insurance, target group of the service and so on. The aim of the project is to assess how equally available councelling services are in Switzerland.

## Project source material:

The list of profile links were scraped on 8th of May 2024. At this time the psyfinder website included the profiles of 3738 psychologists in Switzerland.

Shapefiles for the map visualisations were downloaded from Kanton Luzerns Geodata portal: <https://daten.geo.lu.ch/produkt/grzplzxx_ds_v1>

The excel file for population in each postcode area in Switzerland was downloaded from the Swiss Federal Statistical Office: <https://www.bfs.admin.ch/asset/de/26565300>

The relevant data (newest population data per postal code) was selected in excel and separated to a new file.

The data corresponds to population data from 2022, which was deemed as adequate for the scope of this project.

## Project rundown

## 1. Scraping the data

### 1.1. Initial preparations

The project started by investigation of the website to be scraped (psyfinder.ch). As the website included dynamic elements, i.e. infinite scrolling, it was necessary to first access the page with Selenium powered external browser that was used to scroll to the end of the list.

```{r cars}
library(RSelenium)
library(wdman)

rd <- rsDriver(browser = "firefox",
               chromever = NULL)

driver <- rd$client

#setting the window size as phone adapted website is easier to manage

driver$setWindowSize(360, 640)


#navigating to the website with the selenium driver
driver$navigate('https://www.psychologie.ch/en/psyfinder-map')

html <- driver$getPageSource()[[1]]
print(html)

pageEl  <- driver$findElements(using = "css", value = "a")

#clicking open the button to show all the results
button_element <- driver$findElement(using = "class name", "d-md-none")
button_element$clickElement()

#scrolling to the bottom of the page to load all the results
scroll_element <- driver$findElement(using = "class name", "overflow-scroll")
scroll_element$sendKeysToElement(list(key = "end"))

#creating a loop that does the infine scroll

for(i in 1:50){
  scroll_element$sendKeysToElement(list(key = "end"))
  Sys.sleep(8)
}

```

This result was saved in an HTML file in order to scrape the eventual profile links

```{r}
html <- driver$getPageSource()[[1]]
writeLines(html, "psyfinder.html")

```

### 1.2 Scraping the profile links

To scrape the needed information from the counsellor profiles on the psyfinder-website it was necessary to create a list of profile links to be used in the scraping process.

```{r}
library(rvest)
library(httr)

links <- read_html("psyfinder.html") %>%
  html_elements(css = "a") %>%
  html_attr(name = "href")

#checking where the profile links start and end

links[1:60]

links[3700:3796]

#profile links start at 56 and end at 3793

links_profiles <- links[56:3793]

#Saving the links to a csv file

write.csv(links_profiles, "profilelinks.csv", row.names = FALSE)
```

The list links_profiles includes only the profile links (n = 3738).

To scrape the right information from the profile, an example code was created.

To extract the information under titles "Address", "Target groups", "Languages", "Availability" and "Billing", it was necessary to find the correct Xpath node to access this information. This process included several trials where using the parent notation returned the right results.

The code below provides an example for fetching the address - replacing it with the other keywords returned the corresponding right information.

Additionally, new variable "post code" was formed for the analysis.

```{r}

#reading the needed information from the first profile in the html file

test <- read_html(links_profiles[1]) %\>% html_elements(xpath = '//h3[.="Address"]/parent::div') %\>% html_text2() %\>% str_replace("Address\n", "") %\>% str_replace_all("\n", " ")

# Extract the zipcode of 4 digits from the address string
zipcode <- str_extract(test, "\\d{4}")
```

Finally, this information was scraped from all the profiles to form a dataset for later analysis.

```{r}
#turning links_profiles into a character vector
psychologist_combined <- data.frame(Title = character(), stringsAsFactors = FALSE)

i <- 0
for (profile_link in links_profiles) {
  i <- i + 1
  pages <- GET(
    profile_link,
    add_headers(From = "heini.jaervioe@stud.unilu.ch", 'User-Agent' = R.Version()$version.string)
  )
  if (status_code(pages) == 200) {
    # Check if the request was successful
    print("Success!")
  } else {
    print("Error!")
    print(status_code(pages))
  }
  Sys.sleep(5)
  
  
  bin <- content(pages, as = "parsed")
  
  availability <- bin %>%
    html_elements(xpath = '//div[.="Availability"]/parent::div') %>%
    html_text2() %>%
    strsplit("\n")
  
  group <- bin %>%
    html_elements(xpath = '//div[.="Target groups"]/parent::div') %>%
    html_text2() %>%
    strsplit("\n")
  
  bill <- bin %>%
    html_elements(xpath = '//div[.="Billing"]/parent::div') %>%
    html_text2() %>%
    strsplit("\n")
  
  lang <- bin %>%
    html_elements(xpath = '//div[.="Languages"]/parent::div') %>%
    html_text2() %>%
    strsplit("\n")
  
  addr <- bin %>%
    html_elements(xpath = '//h3[.="Address"]/parent::div') %>%
    html_text2() %>%
    str_replace("Address\n", "") %>%
    str_replace_all("\n", " ")
  
  zipcode <- str_extract(addr, "\\d{4}")

  
  data <- list(
    address = addr[[1]][1],
    availability = availability[[1]][2],
    groups = group[[1]][2],
    languages = lang[[1]][2],
    billing = bill[[1]][2],
    zipcode = zipcode
  )
  
  
  psychologist_df <- data.frame(data)
  
  psychologist_combined <- rbind.data.frame(psychologist_combined, psychologist_df)
}

```

The data was the saved to a csv file for further analysis.

```{r}
write.csv(psychologist_combined, "psychologist_combined.csv", row.names = FALSE)
```

## 2. Data analysis

### 2.1. Data cleaning

As the postcode is one of the most central variables in the analysis, it was necessary to check the quality of the data. The code below checks the number of missing/invalid values in the postcode variable.

```{r}
#find out all the unique values in the column zipcode

zipcode_list <- unique(data$zipcode)

#sorting the list

zipcode_list <- sort(zipcode_list)

zipcode_list

#data includes zipcodes that are not valid, so we need to filter out the invalid zipcodes

valid_zipcode <- zipcode_list[grepl("^\\d{4}$", zipcode_list)]

print(valid_zipcode)

#removing the profiles with invadid zipcodes from the data

psychologist_df <- data %>% filter(zipcode %in% valid_zipcode)
```

After filtering 3723 profiles were left for further analysis.

### 2.2. Desprictive statistics

Which zipcodes have the most psychologists? This was assessed by counting the number of psychologists in each postcode area.

```{r}
zipcode_count <- psychologist_df %>% group_by(zipcode) %>% summarise(count = n()) %>% arrange(desc(count))

zipcode_count

#checking the count for larger areas and filtering by the first digit of the poistcode

zipcode_count$first_digit <- substr(zipcode_count$zipcode, 1, 1)

zipcode_count <- zipcode_count %>% group_by(first_digit) %>% summarise(count = sum(count)) %>% arrange(desc(count))

zipcode_count
```

The zipcodes with the most psychologists are: 1003 with 141 psychologists, 3011 with 124 psychologists and 8006 with 99 psychologists

Zipcodes starting with 1 have the highest number of psychologist (1208), then 8 / Zurich (946), 3/ Bern (418), 6/ Luzern (395)

Coverance by basic insurance was also assessed.

```{r}
psychologist_df$billing <- as.factor(psychologist_df$billing)

psychologist_df %>% group_by(billing) %>% summarise(count = n()/3723)
```

15 % don't have "covered by basic insurance" in their profile, whereas 85 % do. We land on the conclusion that the majority of psychologists in Switzerland are covered by basic insurance.

What about the availabitlity of the psychologists?

```{r}
psychologist_df %>% group_by(availability) %>% summarise(count = n()/3723)
```

15,8 % are available in less than 2 weeks, 22,3 % in 2-4 weeks, 32,7 % at least four weeks, 29,2 % don't have any availability. For 60 % of the psychologist one has to wait at least 4 weeks

Finally, a pie chart was created to visualise the availability of the psychologists.

```{r}
availability_pie <- psychologist_df %>% 
  group_by(availability) %>% 
  summarise(count = n()) %>% 
  ggplot(aes(x = "", y = count, fill = availability)) +
  geom_bar(stat = "identity") +
  coord_polar("y", start = 0) +
  theme_void() +
  theme(legend.position = "bottom") +
  labs(title = "Availability of psychologists in Switzerland")

availability_pie

```

![Image 1. Availability of all psychologist](images/clipboard-3917257867.png){width="350"}

Lastly, the availability of psychological councelling for different groups was assessed. A sample of target groups was selected as these groups seem like the most common ones.

```{r}
keywords <- c("Children", "Teenagers", "Adults", "Couples")

count_keyword <- function(keyword) {
  str_detect(psychologist_df$groups, regex(paste0("\\b", keyword, "\\b"), ignore_case = TRUE))
}

# Apply the function to each keyword and sum the results
keyword_counts <- sapply(keywords, function(keyword) sum(count_keyword(keyword)))

keyword_percentages <- (keyword_counts / 3723) * 100

# Convert to a data frame for better readability
keyword_counts_df <- data.frame(keyword = keywords, count = keyword_counts, percentage = keyword_percentages)

# Print the table
print(keyword_counts_df)
```

The following table was created:

```         
            keyword count percentage 
Children   Children   979   26.29600 
Teenagers Teenagers  1543   41.44507 
Adults       Adults  3598   96.64249
Couples     Couples  1327   35.64330
```

The majority of psychologists in Switzerland provide services for adults, while the availability of services for children, teenagers and couples is lower.

Finally, the availability of counseling in different languages was analysed. A selection of some common languages were picked and their frequency in the data analysed.

```{r}
print(psychologist_df$languages)

if (any(is.na(psychologist_df$languages))) {
  stop("There are NA values in the languages column.")
}

#There are NA values in the languages so we need to adjust the code slightly

languages <- c("English", "German", "French", "Italian", "Swiss", "Portuguese", "Russian", "Arabic", "Turkish", "Chinese", "Serbian", "Spanish")

count_language <- function(language) {
  detected <- str_detect(coalesce(psychologist_df$languages, ""), regex(paste0("\\b", language, "\\b"), ignore_case = TRUE))
  print(paste("Language:", language))
  print(detected)
  return(detected)
}

# Apply the function to each keyword and sum the results
language_counts <- sapply(languages, function(language) sum(count_language(language)))

print(language_counts)
language_percentages <- (language_counts / 3723) * 100

language_counts_df <- data.frame(keyword = languages, count = language_counts, percentage = language_percentages)

# Print the table and organise the results by highest percentage first

language_counts_df <- language_counts_df[order(-language_counts_df$percentage), ]

print(language_counts_df)
```


The following table shows the number of psychologists providing counseling in the selected languages and their percentage share of all psychologists.

```         
              keyword count percentage 
German         German  2180 58.5549288 
French         French  1735 46.6022025 
English       English  1558 41.8479721 
Swiss           Swiss  1216 32.6618319 
Italian       Italian   545 14.6387322 
Spanish       Spanish   284  7.6282568 
Portuguese Portuguese   112  3.0083266 
Russian       Russian    30  0.8058018 
Turkish       Turkish    25  0.6715015 
Serbian       Serbian    24  0.6446414 
Arabic         Arabic    19  0.5103411 
Chinese       Chinese     0  0.0000000
```

### 2.3 Map visualisations

The data was visualised on a map to assess whether different areas have equal access to psychological counseling.

```{r}
library(sf)
library(leaflet)
library(tmap)
library(dplyr)
library(shinyjs)

#reading the shp file for a map of switzerland with zipcode areas to R

mapdata <- sf::st_read("zipcodemap.shp")

#checking that the data was read correctly

print(mapdata)

#plotting the map

tmap_mode("plot")

#renaming the zipcode column to "PLZ" to match with the names in the shapefile

psychologist_df$PLZ <- psychologist_df$zipcode
```

Four maps were created as follows:

1.  Number of psychologists in each area code

```{r}
#creating a map that shows the number of psychologists in each zipcode. We use log2 to make the differences more visible

psyc_count <- psychologist_df %>% group_by(PLZ) %>% summarise(count = n())

#merging the zipcode_count dataframe with the mapdata dataframe

mapdata <- merge(mapdata, psyc_count, by.x = "PLZ", by.y = "PLZ", all.x = TRUE)

mapdata$log2_count <- log2(mapdata$count)

tm_shape(mapdata) +
  tm_polygons(col = "log2_count", 
              border.col = "grey",
              lwd = 0.05,
              palette = "BuPu", 
              n = 6,
              style = "pretty",
              colorNA = "white") +
  tm_layout(main.title = "Log2 of number of psychologist in each zipcode",
            main.title.size = 0.8,
            bg.color = "grey85",
            legend.outside = TRUE,
            legend.position = c("right", "bottom"))

```

![Image 2. Number of psychologist in each area code](images/map_psychPLZ.png)

2.  Population in each area code

```{r}
popdata <- read.csv("populationPLZ.csv")

#selecting columns of interest

View(popdata)

#ccreating a map that shows the population in each zipcode to visually compare with the number of psychologists

mapdata <- merge(mapdata, popdata, by.x = "PLZ", by.y = "PLZ", all.x = TRUE)

tm_shape(mapdata) +
  tm_polygons(col = "N", 
              border.col = "grey",
              lwd = 0.1,
              palette = "BuPu", 
              n = 6,
              style = "pretty",
              colorNA = "white") +
  tm_layout(main.title = "Population in each zipcode",
            main.title.size = 0.8,
            bg.color = "grey85",
            legend.outside = TRUE,
            legend.position = c("right", "bottom"))
```

![Image 3. Population in each zipcode](images/map_popPLZ.png)

3.  Relative number of psychologists per population in each zipcode

```{r}
mapdata$pop_psyc <- mapdata$N/mapdata$count

tm_shape(mapdata) +
  tm_polygons(col = "pop_psyc", 
              border.col = "grey",
              lwd = 0.1,
              palette = "BuPu", 
              n = 6,
              style = "pretty",
              colorNA = "white") +
  tm_layout(main.title = "Population / psychologist in each postcode",
            main.title.size = 0.8,
            bg.color = "grey85",
            legend.outside = TRUE,
            legend.position = c("right", "bottom"))


```

![Image 4. Population / psychologist share in each zipcode](images/map_psychpop.png)

4.  Availability of counseling around Switzerland

```{r}
#checking which values the availablity variable in psychologist_df takes

unique(psychologist_df$availability)

#assigning a numerical value to the availability variable

availability_to_numeric <- function(availability) {
  if (availability == "Less than two weeks") {
    return(1)
  } else if (availability == "Two to four weeks") {
    return(2)
  } else if (availability == "At least four weeks") {
    return(3)
  } else if (availability == "No date currently available") {
    return(4)
  } else {
    return(NA)  # or another default value if needed
  }
}

psychologist_df <- psychologist_df %>%
  mutate(availability_numeric = sapply(availability, availability_to_numeric))

View(psychologist_df$availability_numeric)

#creating a map that shows the average availability of psychologists in each zipcode

psyc_availability <- psychologist_df %>% group_by(PLZ) %>% summarise(availability_numeric = mean(availability_numeric, na.rm = TRUE))

mapdata <- merge(mapdata, psyc_availability, by.x = "PLZ", by.y = "PLZ", all.x = TRUE)

mapdata <- mapdata %>%
  mutate(availability_category = cut(availability_numeric,
                                     breaks = c(-Inf, 1.5, 2.5, 3.5, Inf),
                                     labels = c("Good availability", "Fairly good availability", "Low Availability", "No availability")))

tm_shape(mapdata) +
  tm_polygons(col = "availability_category", 
              border.col = "grey",
              lwd = 0.1,
              palette = "BuPu", 
              n = 4,
              style = "pretty",
              colorNA = "white") +
  tm_layout(main.title = "Availability of psychologists in each zipcode",
            main.title.size = 0.8,
            bg.color = "grey85",
            legend.outside = TRUE,
            legend.position = c("right", "bottom"))

```

![Image 5. Availability of counseling around Switzerland](images/map_availability.png)

## 3. Conclusions
